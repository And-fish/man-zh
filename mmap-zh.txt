MMAP(2)                                                                                 Linux Programmer's Manual                                                                                 MMAP(2)

NAME
       mmap, munmap - 用于 映射/取消映射 文件/设备 到内存中

SYNOPSIS
       #include <sys/mman.h>

       void *mmap(void *addr, size_t length, int prot, int flags,
                  int fd, off_t offset);
       int munmap(void *addr, size_t length);

       关于其他特殊的需求请参考NOTES;

DESCRIPTION
       mmap()会在调用进程的虚拟地址空间中创建一个新的映射.新映射的起始地址由addr指定, length参数用于指定映射的长度(必须要大于0);

       如果addr被指定为NULL，kernel会选择一个地址去创建映射;这是创建一个新的映射可移植性最强的方法.
       如果addr不是NULL,kernel会将它作为映射地点的"坐标",会在addr附近的页边界创建映射;
       调用的返回的结果是新映射的地址.

       与匿名映射(参见 MAP_ANONYMOUS)相反的是,文件映射的内容是,从文件描述符fd引用的文件(或者其他对象)的offset开始的;
       offset必须是sysconf(_SC_PAGE_SIZE)返回的页面大小的倍数;

       port参数用于描述所需的内存权限(并且不能和文件的打开模式冲突).port要么是PROT_NONE,要么是下面中一个或者多个标志的 "|";

       PROT_EXEC  Pages可以被执行。

       PROT_READ  Pages可以被读取。

       PROT_WRITE Pages可以被写入。

       PROT_NONE  Pages无法访问。

       flags参数用于确定对映射的修改是否对其他的进程可见，以及修改是否被传递到底层文件;这些行为会通过flags包含的值来确定:

       MAP_SHARED
              表示会共享这块映射;对映射的修改对于其他的进程是可见的，并且会传递到底层文件上(在文件支持映射的情况下);
              (如果需要手动精确的控制何时更新到底层文件可以通过msync(2)强制同步到磁盘)

       MAP_PRIVATE
              创建一个私有的写时复制的映射.该映射的修改对于投射同一个文件的其他进程是不可见的，并且不会被磁盘文件进行修改;
              没有指定调用mmap()后对文件的修改是否在映射区域可见

       PS:
            共享型:
              在线性区页上的任何写操作都会修改磁盘文件;并且，如果进程对共享映射中的一个页进行写,那么这种修改会被其他也映射了同一文件的所有进程来说都是可见的;
            私有型:
              当进程创建的映射只是为读文件,而不是写文件时才会使用这种映射;
              出于这种目的，私有映射的效率要比共享映射的效率更快,但是对于私有映射页的任何写操作都会使内核停止映射该文件中的页;
              因此,写操作既不会改变磁盘上的文件,对于访问相同文件的其他进程也是不可见的.
              但是私有内存映射中还没有被进程改变的页会因为其他进程进行的文件更而更新;
        
       这两个flage在 POSIX.1-2001 and POSIX.1-2008 中都有描述;

       下面中的0个或者多个flags可以通过"|"被使用:

       MAP_32BIT (since Linux 2.4.20, 2.6)
              将映射放到进程地址空间的前2GB;这个flags仅在x86-64上对于64位程序被支持.
              它的添加是为了允许线程堆栈在前2GB的内存中，以提高一些早期64位处理器上的上下文切换的性能;
              现代的x86-64处理器不再有这种性能问题，所以在这些系统上不需要使用这个标志;
              当设置MAP_FIXED后， MAP_32BIT会被忽略.

       MAP_ANON
              MAP_ANONYMOUS的同义词.  已被弃用.

       MAP_ANONYMOUS
              映射不受任何文件支持;内容初始值被初始化为0,fd参数会被忽略;
              然而，如果指定了MAP_ANONYMOUS (or  MAP_ANON)，有些实现会要求fd == -1，在设计可移植程序的时候应该要确保这一点;
              offset参数应该要为0;
              从kernel 2.4开始才支持将 MAP_ANONYMOUS 和 MAP_SHARED结合使用

       MAP_DENYWRITE
              该标志已被忽略  (很久以前，它被用于ETXTBUSY向磁盘文件写入的尝试应该失败.  But this was a source of denial-of-service attacks.)

       MAP_EXECUTABLE
              This flag is ignored.

       MAP_FILE
              Compatibility flag.  Ignored.

       MAP_FIXED
              Don't interpret addr as a hint: place the mapping at exactly that address.  addr must be suitably aligned: for most architectures a multiple of the page size is sufficient; however,  some
              architectures  may impose additional restrictions.  If the memory region specified by addr and len overlaps pages of any existing mapping(s), then the overlapped part of the existing map‐
              ping(s) will be discarded.  If the specified address cannot be used, mmap() will fail.  Software that aspires to be portable should use this option with care, keeping  in  mind  that  the
              exact layout of a process's memory mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases.

              Furthermore,  this  option  is  extremely hazardous (when used on its own), because it forcibly removes preexisting mappings, making it easy for a multithreaded process to corrupt its own
              address space.

              For example, thread A looks through /proc/<pid>/maps and locates an available address range, while thread B simultaneously acquires part or all of that same address range.  Thread A  then
              calls mmap(MAP_FIXED), effectively overwriting the mapping that thread B created.

              Thread  B  need  not create a mapping directly; simply making a library call that, internally, uses dlopen(3) to load some other shared library, will suffice.  The dlopen(3) call will map
              the library into the process's address space.  Furthermore, almost any library call may be implemented in a way that adds memory mappings to the address space, either with this technique,
              or by simply allocating memory.  Examples include brk(2), malloc(3), pthread_create(3), and the PAM libraries ⟨http://www.linux-pam.org⟩.

       MAP_GROWSDOWN
              This  flag  is  used for stacks.  It indicates to the kernel virtual memory system that the mapping should extend downward in memory.  The return address is one page lower than the memory
              area that is actually created in the process's virtual address space.  Touching an address in the "guard" page below the mapping will cause the mapping to grow by a page.  This growth can
              be repeated until the mapping grows to within a page of the high end of the next lower mapping, at which point touching the "guard" page will result in a SIGSEGV signal.

       MAP_HUGETLB (since Linux 2.6.32)
              Allocate the mapping using "huge pages."  See the Linux kernel source file Documentation/vm/hugetlbpage.txt for further information, as well as NOTES, below.

       MAP_HUGE_2MB, MAP_HUGE_1GB (since Linux 3.8)
              Used in conjunction with MAP_HUGETLB to select alternative hugetlb page sizes (respectively, 2 MB and 1 GB) on systems that support multiple hugetlb page sizes.

              More  generally,  the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the offset MAP_HUGE_SHIFT.  (A value of zero in
              this bit field provides the default huge page size; the default huge page size can be discovered vie the Hugepagesize field exposed by /proc/meminfo.)  Thus, the above two  constants  are
              defined as:

                  #define MAP_HUGE_2MB    (21 << MAP_HUGE_SHIFT)
                  #define MAP_HUGE_1GB    (30 << MAP_HUGE_SHIFT)

              The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in /sys/kernel/mm/hugepages.

       MAP_LOCKED (since Linux 2.5.37)
              Mark  the mapped region to be locked in the same way as mlock(2).  This implementation will try to populate (prefault) the whole range but the mmap() call doesn't fail with ENOMEM if this
              fails.  Therefore major faults might happen later on.  So the semantic is not as strong as mlock(2).  One should use mmap() plus mlock(2) when major faults are not  acceptable  after  the
              initialization of the mapping.  The MAP_LOCKED flag is ignored in older kernels.

       MAP_NONBLOCK (since Linux 2.5.46)
              This  flag  is meaningful only in conjunction with MAP_POPULATE.  Don't perform read-ahead: create page tables entries only for pages that are already present in RAM.  Since Linux 2.6.23,
              this flag causes MAP_POPULATE to do nothing.  One day, the combination of MAP_POPULATE and MAP_NONBLOCK may be reimplemented.

       MAP_NORESERVE
              Do not reserve swap space for this mapping.  When swap space is reserved, one has the guarantee that it is possible to modify the mapping.  When swap space is not reserved one  might  get
              SIGSEGV  upon a write if no physical memory is available.  See also the discussion of the file /proc/sys/vm/overcommit_memory in proc(5).  In kernels before 2.6, this flag had effect only
              for private writable mappings.

       MAP_POPULATE (since Linux 2.5.46)
              Populate (prefault) page tables for a mapping.  For a file mapping, this causes read-ahead on the file.  This will help to reduce blocking on page faults later.  MAP_POPULATE is supported
              for private mappings only since Linux 2.6.23.

       MAP_STACK (since Linux 2.6.27)
              Allocate the mapping at an address suitable for a process or thread stack.  This flag is currently a no-op, but is used in the glibc threading implementation so that if some architectures
              require special treatment for stack allocations, support can later be transparently implemented for glibc.

       MAP_UNINITIALIZED (since Linux 2.6.33)
              Don't clear anonymous pages.  This flag is intended to improve performance on embedded devices.  This flag is honored only if the kernel was configured with  the  CONFIG_MMAP_ALLOW_UNINI‐
              TIALIZED option.  Because of the security implications, that option is normally enabled only on embedded devices (i.e., devices where one has complete control of the contents of user mem‐
              ory).

       Of the above flags, only MAP_FIXED is specified in POSIX.1-2001 and POSIX.1-2008.  However, most systems also support MAP_ANONYMOUS (or its synonym MAP_ANON).

       Memory mapped by mmap() is preserved across fork(2), with the same attributes.

       A file is mapped in multiples of the page size.  For a file that is not a multiple of the page size, the remaining memory is zeroed when mapped, and writes to that region are not written out  to
       the file.  The effect of changing the size of the underlying file of a mapping on the pages that correspond to added or removed regions of the file is unspecified.

   munmap()
       The  munmap()  system call deletes the mappings for the specified address range, and causes further references to addresses within the range to generate invalid memory references.  The region is
       also automatically unmapped when the process is terminated.  On the other hand, closing the file descriptor does not unmap the region.

       The address addr must be a multiple of the page size (but length need not be).  All pages containing a part of the indicated range are unmapped, and subsequent references  to  these  pages  will
       generate SIGSEGV.  It is not an error if the indicated range does not contain any mapped pages.

RETURN VALUE
       On success, mmap() returns a pointer to the mapped area.  On error, the value MAP_FAILED (that is, (void *) -1) is returned, and errno is set to indicate the cause of the error.

       On success, munmap() returns 0.  On failure, it returns -1, and errno is set to indicate the cause of the error (probably to EINVAL).

ERRORS
       EACCES A file descriptor refers to a non-regular file.  Or a file mapping was requested, but fd is not open for reading.  Or MAP_SHARED was requested and PROT_WRITE is set, but fd is not open in
              read/write (O_RDWR) mode.  Or PROT_WRITE is set, but the file is append-only.

       EAGAIN The file has been locked, or too much memory has been locked (see setrlimit(2)).

       EBADF  fd is not a valid file descriptor (and MAP_ANONYMOUS was not set).

       EINVAL We don't like addr, length, or offset (e.g., they are too large, or not aligned on a page boundary).

       EINVAL (since Linux 2.6.12) length was 0.

       EINVAL flags contained neither MAP_PRIVATE or MAP_SHARED, or contained both of these values.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENODEV The underlying filesystem of the specified file does not support memory mapping.

       ENOMEM No memory is available.

       ENOMEM The process's maximum number of mappings would have been exceeded.  This error can also occur for munmap(), when unmapping a region in the  middle  of  an  existing  mapping,  since  this
              results in two smaller mappings on either side of the region being unmapped.

       ENOMEM (since Linux 4.7) The process's RLIMIT_DATA limit, described in getrlimit(2), would have been exceeded.

       EOVERFLOW
              On  32-bit architecture together with the large file extension (i.e., using 64-bit off_t): the number of pages used for length plus number of pages used for offset would overflow unsigned
              long (32 bits).

       EPERM  The prot argument asks for PROT_EXEC but the mapped area belongs to a file on a filesystem that was mounted no-exec.

       EPERM  The operation was prevented by a file seal; see fcntl(2).

       ETXTBSY
              MAP_DENYWRITE was set but the object specified by fd is open for writing.

       Use of a mapped region can result in these signals:

       SIGSEGV
              Attempted write into a region mapped as read-only.

       SIGBUS Attempted access to a portion of the buffer that does not correspond to the file (for example, beyond the end of the file, including the case  where  another  process  has  truncated  the
              file).

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌───────────────────┬───────────────┬─────────┐
       │Interface          │ Attribute     │ Value   │
       ├───────────────────┼───────────────┼─────────┤
       │mmap(), munmap()   │ Thread safety │ MT-Safe │
       └───────────────────┴───────────────┴─────────┘
CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD.

AVAILABILITY
       On POSIX systems on which mmap(), msync(2), and munmap() are available, _POSIX_MAPPED_FILES is defined in <unistd.h> to a value greater than 0.  (See also sysconf(3).)

NOTES
       On  some  hardware  architectures  (e.g.,  i386),  PROT_WRITE  implies  PROT_READ.   It is architecture dependent whether PROT_READ implies PROT_EXEC or not.  Portable programs should always set
       PROT_EXEC if they intend to execute code in the new mapping.

       The portable way to create a mapping is to specify addr as 0 (NULL), and omit MAP_FIXED from flags.  In this case, the system chooses the address for the mapping; the address is chosen so as not
       to conflict with any existing mapping, and will not be 0.  If the MAP_FIXED flag is specified, and addr is 0 (NULL), then the mapped address will be 0 (NULL).

       Certain flags constants are defined only if suitable feature test macros are defined (possibly by default): _DEFAULT_SOURCE with glibc 2.19 or later; or _BSD_SOURCE or _SVID_SOURCE in glibc 2.19
       and earlier.  (Employing _GNU_SOURCE also suffices, and requiring that macro specifically would have been more logical, since these flags  are  all  Linux-specific.)   The  relevant  flags  are:
       MAP_32BIT, MAP_ANONYMOUS (and the synonym MAP_ANON), MAP_DENYWRITE, MAP_EXECUTABLE, MAP_FILE, MAP_GROWSDOWN, MAP_HUGETLB, MAP_LOCKED, MAP_NONBLOCK, MAP_NORESERVE, MAP_POPULATE, and MAP_STACK.

       An application can determine which pages of a mapping are currently resident in the buffer/page cache using mincore(2).

   Timestamps changes for file-backed mappings
       For  file-backed  mappings, the st_atime field for the mapped file may be updated at any time between the mmap() and the corresponding unmapping; the first reference to a mapped page will update
       the field if it has not been already.

       The st_ctime and st_mtime field for a file mapped with PROT_WRITE and MAP_SHARED will be updated after a write to the mapped region, and before a subsequent msync(2) with the MS_SYNC or MS_ASYNC
       flag, if one occurs.

   Huge page (Huge TLB) mappings
       For mappings that employ huge pages, the requirements for the arguments of mmap() and munmap() differ somewhat from the requirements for mappings that use the native system page size.

       For mmap(), offset must be a multiple of the underlying huge page size.  The system automatically aligns length to be a multiple of the underlying huge page size.

       For munmap(), addr and length must both be a multiple of the underlying huge page size.

   C library/kernel differences
       This  page  describes the interface provided by the glibc mmap() wrapper function.  Originally, this function invoked a system call of the same name.  Since kernel 2.4, that system call has been
       superseded by mmap2(2), and nowadays the glibc mmap() wrapper function invokes mmap2(2) with a suitably adjusted value for offset.

BUGS
       On Linux, there are no guarantees like those suggested above under MAP_NORESERVE.  By default, any process can be killed at any moment when the system runs out of memory.

       In kernels before 2.6.7, the MAP_POPULATE flag has effect only if prot is specified as PROT_NONE.

       SUSv3 specifies that mmap() should fail if length is 0.  However, in kernels before 2.6.12, mmap() succeeded in this case: no mapping was created  and  the  call  returned  addr.   Since  kernel
       2.6.12, mmap() fails with the error EINVAL for this case.

       POSIX  specifies  that the system shall always zero fill any partial page at the end of the object and that system will never write any modification of the object beyond its end.  On Linux, when
       you write data to such partial page after the end of the object, the data stays in the page cache even after the file is closed and unmapped and even though the data is never written to the file
       itself,  subsequent mappings may see the modified content.  In some cases, this could be fixed by calling msync(2) before the unmap takes place; however, this doesn't work on tmpfs(5) (for exam‐
       ple, when using the POSIX shared memory interface documented in shm_overview(7)).

EXAMPLE
       The following program prints part of the file specified in its first command-line argument to standard output.  The range of bytes to be printed is specified via offset and length values in  the
       second and third command-line arguments.  The program creates a memory mapping of the required pages of the file and then uses write(2) to output the desired bytes.

   Program source
       #include <sys/mman.h>
       #include <sys/stat.h>
       #include <fcntl.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>

       #define handle_error(msg) \
           do { perror(msg); exit(EXIT_FAILURE); } while (0)

       int
       main(int argc, char *argv[])
       {
           char *addr;
           int fd;
           struct stat sb;
           off_t offset, pa_offset;
           size_t length;
           ssize_t s;

           if (argc < 3 || argc > 4) {
               fprintf(stderr, "%s file offset [length]\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           fd = open(argv[1], O_RDONLY);
           if (fd == -1)
               handle_error("open");

           if (fstat(fd, &sb) == -1)           /* To obtain file size */
               handle_error("fstat");

           offset = atoi(argv[2]);
           pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1);
               /* offset for mmap() must be page aligned */

           if (offset >= sb.st_size) {
               fprintf(stderr, "offset is past end of file\n");
               exit(EXIT_FAILURE);
           }

           if (argc == 4) {
               length = atoi(argv[3]);
               if (offset + length > sb.st_size)
                   length = sb.st_size - offset;
                       /* Can't display bytes past end of file */

           } else {    /* No length arg ==> display to end of file */
               length = sb.st_size - offset;
           }

           addr = mmap(NULL, length + offset - pa_offset, PROT_READ,
                       MAP_PRIVATE, fd, pa_offset);
           if (addr == MAP_FAILED)
               handle_error("mmap");

           s = write(STDOUT_FILENO, addr + offset - pa_offset, length);
           if (s != length) {
               if (s == -1)
                   handle_error("write");

               fprintf(stderr, "partial write");
               exit(EXIT_FAILURE);
           }

           munmap(addr, length + offset - pa_offset);
           close(fd);

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       ftruncate(2),  getpagesize(2),  memfd_create(2),  mincore(2),  mlock(2),  mmap2(2),  mprotect(2),  mremap(2),  msync(2), remap_file_pages(2), setrlimit(2), shmat(2), userfaultfd(2), shm_open(3),
       shm_overview(7)

       The descriptions of the following files in proc(5): /proc/[pid]/maps, /proc/[pid]/map_files, and /proc/[pid]/smaps.

       B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128–129 and 389–391.

COLOPHON
       This page is part of release 4.15 of the Linux man-pages project.  A description of the project, information about reporting bugs,  and  the  latest  version  of  this  page,  can  be  found  at
       https://www.kernel.org/doc/man-pages/.

Linux                                                                                           2017-12-18                                                                                        MMAP(2)
